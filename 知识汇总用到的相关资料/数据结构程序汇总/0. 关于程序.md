**注意：**数据结构程序总体还是比较绕的！所以别在那里死看！ **<u>一定一定 用手用纸 比划一下！</u>**

<u>**最重要的，一定要搞清楚！算法逻辑！**</u>

**<u>灵活运用程序调试功能：</u>**

**结合算法原理讲解视频，擅用 单步执行 与 调试输出！！！**

**比如：**
排序看不懂，链表逆转看不懂……
1\.把数据结构算法 放到 main函数里面 (因为子函数里面 调试器 无法看到数组/结构体里面程序变量)
2\.**直接单步执行**，观察如何执行的；

这样子其实具体细节逻辑就懂了！





# 202406 New：

## 0\. 学习方法：

**数据结构：**
**1\.** 一定理清楚算法思路/逻辑！按照算法思路/逻辑写程序！
**2\.** 程序梳理！灵活运用程序调试！单步执行与调试输出！

**3\.** 梳理算法逻辑！一定一定！用手笔画一下！




## 1\. 文件内容划分：

```
SqList——————顺序表(静态内存)
SeqList——————顺序表(动态内存)

LinkList——————链表——单链表(带头结点)
LinkList2——————链表——单链表(不带头结点)

DLinklist——————链表——双链表

CLinklist——————链表——循环单链表
CDLinklist——————链表——循环双链表

SqStack——————顺序栈
LiStack——————链栈(带头结点)
LiStack2——————链栈(不带头结点)

SqQueue——————顺序队列
LinkQueue——————链队列(带头结点)
LinkQueue2——————链队列(不带头结点)

SString——————串

Sort——————排序算法
```



## 2\. 各个知识内容攒点整理！

### **顺序表：**

```C++
/** 
 * @note
 * 顺序表(静态)结构体:
 * 1. 静态数组(动态指针);
 * 2. 数组当前长度; 
 * 3. 数组最大长度(动态);
 * @note
 * ！操作核心！：
 * 1. 更改顺序表内容;
 * 2. 更改顺序表长度(注意长度从1开始计算);
 * 3. 若销毁顺序表，注意释放占用内存空间;
 * @note
 * !传参！
 * 值传参 → 不对顺序表进行修改
 * 引用传参 → 需要对顺序表进行修改
 * @note
 * 数组栈顶位置，指的是**当前**线性表最后一个元素所在的下标
 * @note
 * 注意！
 * 后面发现，插入/删除元素，容易搞混，理论位置/实际位置(从1开始)
 * 所以自己写程序，放纵一些，
 * 元素temp_i直接=i-1；length = L.length-1得了……(相当于顺序表从0开始)
 * 传入/传出记着+-1！
 * @note
 * 需要执行判断：
 * 元素序号过小(<1)/过大(>顺序表长度) 或是 顺序表已满
 * @note 常见操作；
 *       初始化：顺序表分配空间，顺序表数据元素清零，顺序表长度清零(当前长度，最大长度)；
 *       销毁：顺序表释放空间，顺序表长度清零(当前长度，最大长度)；
 *       查找：按位/按值 查找：直接根据数组索引查找就行
 *       插入：元素后移(从表末尾到插入位置)，取入插入元素到修改位置，长度修改
 *       删除：取出删除元素到修改位置，元素前移(从删除位置到表末尾)，长度修改
 */
typedef struct
{
    int *data;   // 声明动态分配数组的指针
    int MaxSize; // 顺序表的最大容量
    int length;  // 顺序表的当前长度
} SeqList;
```

**顺序表画法：**
<img src=".\图片\顺序表.png" alt="顺序表" style="zoom:50%;" />



### **链表：**

```C++
/** 
 * @note
 * 单链表(带/不带头结点)结构体:
 * 1. 头结点(第0个节点);
 * 2. 节点数据;
 * 3. 下一个节点位置指针;
 * 4. 注意链表最后一个元素指向NULL
 * (通过 LNode* 强调返回值节点，LinkList 强调这是一个单链表) 
 * @note
 * ！操作核心！：
 * 1. 链表：下一个节点位置指针 指向地址！(检查最后节点指向NULL)
 * 2. 链表保存值：备份/保存/恢复
 * 3. 若销毁链表，注意释放占用内存空间;
 * @note
 * !传参！
 * 值传参 → 不对头节点指针 指向的地址 进行修改(可以对头结点地址内值可以进行修改)
 * 引用传参 → 需要对头节点指针 指向的地址 进行修改
 * 带头结点链表，头结点L不会改动，只会改动头结点L->next(头结点地址内的值)
 * 不带头结点链表，头结点L会指向新的地址，因此必须使用引用传参
 * @note
 * 注意！
 * 链表专心修改：链表下一个节点位置指针！
 * 对于链表数据，可以定义临时变量保存数据，最后在对不同节点进行数据修改；
 * 基本操作：链表插入数据(当前节点后)：创建temp节点，temp节点next指针指向当前节点next节点，当前节点next指针指向temp节点
 *          链表删除数据(当前节点后)：创建temp节点指针，temp节点指针指向当前节点next节点，当前节点next指针指向当前节点next的next节点，释放temp节点内存
 * @note
 * 需要执行判断：
 * 1. 内存分配，内存分配是否成功(检测指针是否NULL)，
 * 2. 对节点操作，传入节点是否为NULL
 * 3. 对位置操作，传入位置是否<0，(0头结点 1正常节点 <0 false)
 * 4. 遍历链表截止条件：(节点p!=NULL) (节点位序j<i)
 * @note 常见操作；
 *       初始化：分配头结点，头结点指向NULL
 *       销毁：删除节点：删除节点后一个节点，数据交换，释放内存；
 *            删除第i节点：① 查找位序，② 删除节点；
 *            删除整个链表：从头节点开始，下一个节点!=NULL，节点后移，释放内存空间；    头结点指向NULL；
 *       查找：j=0/p=L ; j++/p=p->next ; (截止条件：4.)
 *       修改：
 *       节点后插数据：基本操作：链表插入数据！
 *       节点前插数据：基本操作：链表插入数据！之后交换前后节点数据即可！   
 *       位置i插数据：① 查找位序，② 插入节点；
 *       尾插法创建链表：初始化链表，临时节点指针/尾节点指针，创建节点(临时节点指针)→尾节点指针接收数据/尾节点移动，修改数据，尾指针指向NULL
 *       头插法创建链表：初始化链表，临时节点指针/头节点指针(其实就是表头L)，创建节点(临时节点指针)→头节点指针接收数据，修改数据，尾指针指向NULL 
 * @note
 * 注意：对于不带头结点的链表，所有操作都可以通过：
 *      创建头结点，头结点->next指向第一个节点，这种过渡方法解决！
 * 
 * 基本操作：链表插入数据(头结点)：创建temp节点，temp节点next指针指向之前头结点，更新头结点(头结点指向temp)
 *          链表删除数据(头结点)：创建temp节点指针，temp节点指针指向头结点，更新头结点(头结点指向头结点的next)
 */
typedef struct LNode // 定义单链表结点类型
{
    int data;           // 每个节点存放一个数据元素
    struct LNode *next; // 指针指向下一个节点
} LNode, *LinkList;
```

**链表画法：**
<img src=".\图片\链表.png" alt="链表" style="zoom:60%;" />

**典型实例1：**
链表逆置：
三个指针：O0 总指向头结点指针 , O1 总指向第一个数据的指针 , Ot 临时指针；
操作：O1指针的下一个节点删除(不释放内存)，删除节点保存至Ot指针；	
	    待删除节点Ot插入至O0的下一个节点



#### **双链表：**
！操作核心！：（除1外基本与单链表相同）
	1\. 链表：**上**/下一个节点位置指针 指向地址！**(注意 比单链表 多一个 上节点)**	
	2\. 链表保存值：备份/保存/恢复
	3\. 若销毁链表，注意释放占用内存空间;

**双链表注意事项：**temp_p->next->prior != temp_p (因为可能temp_p->next == NULL)



#### **循环链表：**
（链表 尾指针 的 next 指向L头结点 (而不是 NULL) ）
注意：已知循环链表L，对尾节点插入操作；只需头结点后插入节点，交换插入节点与头结点数据，降低时间复杂度；

**循环双链表 没有 普通双链表 temp_p->next->prior 不存在问题！**



#### 顺序表、链表 优缺点对比：

**顺序表**：
**优点：**随机访问性能好，存储密度高；
**缺点：**插入删除操作不方便，拓展容量不方便；

**链表**：
**优点：**插入和删除操作简单，改变容量方便；
**缺点：**随机访问性能差，存储密度低；

如果 **线性表 长度很短** (10左右)，一般使用顺序表即可。

**需要频繁进行随机访问** 使用顺序表；（排序算法）
如果**不需要频繁随机访问**，但是需要 **频繁进行插入和删除** 或者 **元素占用空间远大于next指针** 建议使用链表；（操作系统，任务优先级链表 / 内存管理内存块链表）



### **栈：**

**顺序栈：**

```C++
/** 
 * @note 
 * 顺序栈 结构体：
 * 1. 静态数组(动态指针);
 * 2. 数组当前长度(×)  数组栈顶位置(√)
 * 3. 数组最大长度(动态);
 * @note
 * ！操作核心！：
 * 1. 更改栈顶元素(入栈/出栈)
 * 2. 更改栈顶位置(注意栈顶位置==数组下标)
 * 3. 若销毁栈，注意释放占用内存空间;
 * @note
 * !传参！
 * 值传参 → 不对栈进行修改
 * 引用传参 → 需要对栈进行修改
 * @note
 * 需要执行判断：
 * 栈空(S.top==-1) 栈满(S.top==MaxSize-1)
 * @note 常见操作；
 *       初始化：栈顶位置 == -1
 *       压栈/出栈：注意栈顶位置==数组下标，出栈移出前位置元素，在移动栈顶位置；入栈需要先将位置后移，在压入元素
 *       判断栈满/栈空：栈空(S.top==-1) 栈满(S.top==MaxSize-1)
 */
typedef struct
{
    int data[MaxSize]; // 静态数组存放栈中元素
    int top;           // 栈顶元素
} SqStack;
```

**链栈：**

```C++
/** 
 * @note 
 * 链栈 结构体：
 * 与 链表 完全相同；
 * @note
 * ！操作核心！：
 * 与 链表 完全相同
 * @note
 * !传参！
 * 值传参 → 不对头节点指针 指向的地址 进行修改(可以对头结点地址内值可以进行修改)
 * 引用传参 → 需要对头节点指针 指向的地址 进行修改
 * 带头结点链表，头结点L不会改动，只会改动头结点L->next(头结点地址内的值)  
 * 			   因此带头结点链表，一直使用值传参即可
 * 不带头结点链表，头结点L会指向新的地址，因此必须使用引用传参
 * 			   因此不带头结点链表，必须使用引用传参
 * @note
 * 需要执行判断：
 * 栈空( S->next==NULL(带头结点)/S=NULL(不带头结点) )
 * @note 常见操作；
 *       初始化：与链表初始化相同
 *       压栈/出栈：头插法 插入元素/删除元素
 *       判断栈满/栈空：栈空( S->next==NULL(带头结点)/S=NULL(不带头结点) )   栈满(不会发生，无需判断)
 */
typedef struct Linknode
{
    int data;              // 数据域
    struct Linknode *next; // 指针域
} Linknode, *LiStack;
```

**栈画法 与 顺序表/链表 完全相同！**



### **队列：**

**顺序队列：**

```C++
/** 
 * @note
 * 循环顺序队列不能使用Q.rear == Q.front作为判空的条件，因为当队列已满时也符合该条件，会与判空发生冲突！
 * 解决方法一：牺牲一个单元来区分队空和队满，即将(Q.rear+1)%MaxSize == Q.front作为判断队列是否已满的条件。（主流方法）
 * 解决方法二：设置 size 变量记录队列长度。
 * @note 
 * 循环顺序队列 结构体：
 * 1. 静态数组(动态指针);
 * 2. 数组当前长度(×)  队头位置(front)和队尾位置(rear)(√)；队头(front)出队，队尾(rear)入队；队头位置/队尾位置=入队元素位置(空无数据)/出队元素位置(实有数据)=数组下标
 * 3. 数组最大长度(动态);
 * @note
 * ！操作核心！：
 * 1. 更改队头队尾元素(入队/出队)
 * 2. 更改队头队尾位置(注意 %MaxSize)
 * 3. 若销毁栈，注意释放占用内存空间;
 * @note
 * !传参！
 * 值传参 → 不对队列进行修改
 * 引用传参 → 需要对队列进行修改
 * @note
 * 需要执行判断：
 * 队空(Q.rear = Q.front) 栈满((Q.rear + 1) % MaxSize == Q.front % MaxSize)
 * @note 常见操作；
 *       初始化：Q.rear(队尾) = Q.front(队头) = 0;
 *       入队：队尾位置输入元素，队尾位置后移 (后移方法：(Q.rear + 1) % MaxSize)      
 *       出队：队头位置输出元素，队头位置后移 (后移方法：(Q.front + 1) % MaxSize)      
 *       判断队满/队空：队空(Q.rear = Q.front) 栈满((Q.rear + 1) % MaxSize == Q.front % MaxSize)  (牺牲一个单元来区分队空和队满)
 */
typedef struct
{
    int data[MaxSize]; // 静态数组存放栈中元素
    int front, rear;   // 队头指针和队尾指针
} SqQueue;
```

**循环顺序队列画法：**
<img src=".\图片\队列.png" alt="队列" style="zoom:45%;" />

**链队列：**

```C++
/** 
 * @note 
 * 链队列 结构体：
 * 1. 链队列 链表节点
 * 2. 定义 链队列 结构体，包含指向链表 头/尾 指针
 * @note
 * ！操作核心！：
 * front永远指向队尾(头结点)，rear永远指向队头(尾巴)
 * @note
 * !传参！
 * 值传参 → 不对头节点指针 指向的地址 进行修改(可以对头结点地址内值可以进行修改)
 * 引用传参 → 需要对头节点指针 指向的地址 进行修改
 * 因为传入参数为 链队列结构体 (不是链头链尾指针)，因此这里必须使用引用传参
 * @note
 * 需要执行判断：
 * 队空( Q.front == Q.rear )
 * @note 常见操作(带头结点)；
 *       初始化：初始化节点，链队列 队头/队尾指针 指向头结点，头结点的next指针指向NULL；
 *       入队：直接在队尾节点后插数据即可，修改队尾指针指向插入数据
 *       出队：直接在头(队头)结点后删除数据即可，(并释放内存空间)，
 *            注：如果Q.rear为待删除节点(Q.rear == p)，注意free(删除节点)后，让Q.rear=Q.front
 *       判断队空：队空( Q.front == Q.rear )
 * @note 常见操作(不带头结点)；
 *       初始化：初始化节点，链队列 队头/队尾指针 指向NULL；
 *       入队：第一个元素入队，新建节点，队头队尾指针指向节点；第二个元素入队，正常后插；
 *       出队：直接删除头结点数据即可，(并释放内存空间)，
 *            注：如果Q.rear为待删除节点(Q.rear == p)，注意free(删除节点)后，让Q.rear=Q.front=NULL
 *       判断队空：队空( Q.front == NULL )
 */
```

**链队列画法 与 链表 相同！**



#### **栈/队列 应用实例：**

**1\. 括号匹配：**
<img src=".\图片\括号匹配.png" alt="括号匹配" style="zoom:40%;" />

**记：**
① 左值入栈，右值出栈
② SUM三种异常：`((]]`	`(()))`	`((())`

**2\. 栈在表达式求值中的应用：**
下标 ① ② ③ 表示从做到右 先后计算顺序
<img src=".\图片\中缀表达式.png" alt="中缀表达式" style="zoom:40%;" />
转换为后缀表达式：
<img src=".\图片\后缀表达式.png" alt="后缀表达式" style="zoom:40%;" />
**计算方法：**
从左到右扫描，扫描到**数字**，入栈；	扫描到**操作符**，出栈两个栈顶元素，执行相应运算，运算结果入栈；

**中缀转后缀：**
遇到操作数，直接加入后缀表达式；
遇到届限符`()`，遇到`(`直接入栈，遇到`)`依次弹出栈内运算符至后缀表达式，直到遇到`)`
遇到运算符，弹出栈内优先级>=当前运算符的所有运算符至后缀表达式，再把当前运算符入栈

**3\. 递归：**
见C语言语法；

实例：斐波那契数列
1、1、2、3、5、8、13、21、34……
F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N\*）

试了下貌似使用 循环 更简单？



### 串

```C++
/*
就是一个：存储数据 char型 的 字符数组
注意：
1. ch[0]不保存数据，串第1个元素 对应 ch[1], ……
2. length 对应串实际长度，如：lenght = 5，即ch[0]~ch[5]，其中ch[0]不保存数据
3. 不以 '\0' 作为结尾……
*/
typedef struct
{
    char ch[MAXLEN];
    int length;
} SString;
```

串主要内容为：子串匹配！

S = 'gooloogooglegoloe';
T = 'google';

**1\. 朴素模式匹配算法：**
~~1\. 变量声明/赋值：初始化：k = 1，用于S串寻找定位，k由串首遍历到串尾；~~
		        	 ~~i = k, j = 1,  i/j 分别用于串S/T匹配计数 (S.ch[i++] == T.ch[j++]，表示串字符相同)~~
~~2\. 循环控制：while (i **<=** S.length && j **<=** T.length)  如果主串遍历完 (表明未找到数据) 或者 子串遍历完 (表明找到数据)~~
    ~~(<= 是因为 串从1开始)~~
~~​    最后 j>T.length，表示找到数据~~

**参考程序，花里胡哨：**
直接：str1从i=0，遍历到结束；
	    <u>while循环(这个没啥意义其实)</u>，j=0/k=i，j/k同步++对比；
	    循环控制：如果相等，++；不相等，break
	    检测到str2遍历完 (注意str2在前)，说明找到子串，返回i；检测到str1遍历完(但str2没有)，说明遍历失败，return-1；

​       也可以 直接strlen获取字符串长度，str1不遍历到结束，遍历到str1len-str2len即可。这样少对str1遍历完判断，更简单。

**2\. KMP算法：** 
2.1 找next数组
2.2 KMP匹配

**2.1 找next数组：**

**手算方法：**
找串前缀/后缀：next[j]=S的最长相等前后缀+1；
e.p：ababab
next[1]=0(始终) | next[2]=1(始终) | next[3]=1(ab a/b) | next[4]=2(aba a/a) | next[5]=3(abab ab/ab) | next[6]=4(ababa aba/aba)

**[编程方法](https://www.bilibili.com/video/BV16X4y137qw/)：**
初始值：i=1 , j=0; next[1]=0;
循环控制：while (i < T.length)  < 是因为：i=T.length，此时完全匹配，不会回溯；
条件：j=0 (表示回溯到起始位置) 或 T.ch[i] == T.ch\[j\] (前字符相同，数组下标后移)
满足：++j / ++i / next[i] = j ；
	   如果 (T.ch[i] == T.ch\[j\]) 表明字符相同，因此只需对前一个next[j]+1
	   如果 (j=0) 表面为第一个字符，此时next[j]=1
不满足：j = next[j]	(不满足，需要j回溯，j回溯到next[j]位置)
本质：next[j+1]最大值next[j]+1，次大值：next[ next[j] ]+1

**什么乱七八糟的！直接参照自己的暴力求解main程序**

**2.2 KMP匹配：**
主要区别在于：**回溯位置**！
初始值：i=1 , j=1 (i主串一直前进、j子串按照next[j]回溯) 	j=1 , 初始不匹配回溯到0 (j=0，不匹配 主串[1] )
循环控制：while (i **<=** S.length && j **<=** T.length)  如果主串遍历完 (表明未找到数据) 或者 子串遍历完 (表明找到数据)
条件：j=0 (表示回溯到起始位置) 或 S.ch[i] == T.ch\[j\] (表示字符相同)；
满足：i/j前进；
不满足：j回溯到next[j]；

返回值：k = i - T.length;



## **查找：**

主要关注：平均查找长度；

**对于有具体元素的数列**，
查找成功长度 = (元素1查找次数 + 元素2查找次数 + ……元素n查找次数) / (总共多少个元素)
查找失败长度 = (区间1查找次数 + 区间2查找次数 + ……区间n查找次数) / (元素可能落在的区间)

**1. 顺序查找(SeqSearch)**
从头查找到尾；
对于长度n顺序表，查找成功长度 (n+1)/2 ，查找失败长度 n+1

**2\. 折半查找(BinarySearch)**
0\. 先把顺序表排序

low指针指向最低位，high指针指向最高位 ，mid=(low+high)/2
每次mid与值对比；mid>值，high=mid-1；mid<值，low=mid+1；
直到 low>high 退出。

折半查找 平均查找长度 → 二叉树！
<img src=".\图片\折半查找.png" alt="\折半查找" style="zoom:50%;" />
<img src=".\图片\查找.png" alt="查找" style="zoom:25%;" />

**3\. 哈希查找(HashSearch)**

哈希表，数据元素的关键位置 与 存储地址 直接相关

除留余数法：H(key) = key % p；
哈希表长度为m，取一个不大于m但最接近或等于m的质数；

直接定址法：H(key) = key % a + b；

数字分析法：
平方取中法：

处理冲突方法：

开放定址法：就是说冲突后，可以放到其他位置；
线性探测法：就是往相邻后一个元素存放；查找时，一直查找到空，才算停止；

ASL计算方法：
查找成功：所有元素查找次数计算/元素个数
查找失败：落在0/1/2/3……上面的元素，每个元素的最多查找次数 / 可能落在的位置

平方探测法：
d=0/1/-1/4/-4/9/-9 ……
散列表长度m必须是4j+3质数，如7/11/19 (15不行)
可以避免堆积。

——————————

其实一般哈希表用链式存储的更多！……
<img src=".\图片\哈希.png" alt="哈希" style="zoom:50%;" />



## 排序：

插入排序：
    直接插入排序：
    希尔排序：
选择排序：
    选择排序：
    堆排序：
交换排序：
    冒泡排序：
    快速排序：
归并排序：
基数排序：
[排序算法：](https://www.bilibili.com/video/BV1WP411c7hS/)
<img src=".\图片\排序复杂度.png" alt="排序复杂度" style="zoom:50%;" />

### **1\. 简单的排序算法：**

#### **1.1 冒泡排序 (BubbleSort)**

从后往前 (或从前往后) 两两比较相邻元素的值，若为逆序(即A[i]>A[i+1])，则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。

定义：i(外循环)，j(内循环)，flag(表示冒泡是否有元素交换，可省)；
i=0;   i<length；（累计进行 length-1 次排序，-1 数组长度从0开始）
j=0;   j<length - i - 1；（[i]与[i+1]比较，A[i]>A[i+1]，交换位置，完成一次冒泡排序）（第一次 0~length-1 ）

补充：对于大循环i，若后续无冒泡，说明已排序好，无需冒泡；

时间复杂度O(n^2)，空间复杂度O(1)，稳定；



#### **1.2 选择排序 (SelectionSort)** 

每一趟在待排序元素中选取关键字最小的元素加入有序子序列。

定义：i(外循环)，j(内循环)
i=0；i<length；（累计进行 length-1 次排序，-1 数组长度从0开始）
j=i；j<length；（min=i，if [j]<[min]，min=j）最后交换 min 和 i

时间复杂度O(n^2)，空间复杂度O(1)，不稳定；



#### **1.3 插入排序 (InsertionSort)** 

每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。

定义：i(外循环)，j(内循环)，temp(临时数据记录保存)
i=0+1；i<length；（累计进行 length-1 次排序，-1 数组长度从0开始，初始值 i=1 表示 i=1 有序）
if [i-1]>[i] 需要进行排序，
此时temp=arr[i]，j从i-1遍历到0，若满足arr[j]<=temp退出，若不满足，此时数据后移([j+1]=[j])；
退出后此时[j+1]=temp

时间复杂度O(n^2)，空间复杂度O(1)，稳定；



### 2. 有点复杂的排序算法

#### **2.1 希尔排序 (ShellSort)**

先将待排序表分割成若干形如 L[i, i + d,i + 2d.. , i + kd] 的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。

**2.1.1 手算：**
   			<img src=".\图片\希尔排序0.png" alt="希尔排序0" style="zoom:50%;" />	
<img src=".\图片\希尔排序1.png" alt="希尔排序1" style="zoom:50%;" />
<img src=".\图片\希尔排序2.png" alt="希尔排序2" style="zoom:50%;" />
<img src=".\图片\希尔排序3.png" alt="希尔排序3" style="zoom:50%;" />

**2.1.2 程序：**

定义：increasement(增量)，subarr (子表数目及首地址)，i (插入排序外循环)，j (插入排序内循环)，temp (临时数据记录保存)

计算第一步增量（计算方法由题目获取，一般 len/2   ）
while(增量>=1)  {希尔排序     increase = increase/2}

接下来对 increasement 个子表进行排序 
(subarr = 0,  subarr < increase)，subarr 这里是对应第 0/1/....../increase-1 子表首元素地址，

子表划分好，使用选择排序方法即可

定义：i(外循环)，j(内循环)，temp(临时数据记录保存)
i=subarr+increase；i<length；i+=increase~~（累计进行 length-1 次排序，-1 数组长度从0开始，初始值 i=1 表示 i=1 有序）~~
if [i-increase]>[i] 需要进行排序，
此时temp=arr[i]，j从i-increase遍历到>=0，若满足arr[j]<=temp退出，若不满足，此时数据后移([j+increase]=[j])；
退出后此时[j+increase]=temp

时间复杂度O(n^1.3)，空间复杂度O(1)，不稳定；



#### 2.2 堆排序 (HeapSort)

思路：就是构建堆；
大根堆：每个节点的值都大于或者等于他的左右孩子节点的值
大根堆 (存储方式)：
<img src=".\图片\堆1.png" alt="堆1" style="zoom:50%;" />
大根堆 (二叉树画法)：
<img src=".\图片\堆2.png" alt="堆2" style="zoom:50%;" />

**2.2.1 手算：**

理解原理，手算即可。

**2.1.2 程序：**

**1）调整为大根堆 HeadAdjust()：**

输入参数：arr[] (原始待排序数组)，dad(根(父)节点位序)，len(数组长度(数组元素个数+1) )；

int son=2\*dad
循环：son<=len ;   （<=len，是因为下标从1开始，如果从0开始，此时根节点变成 **2\*dad+1**）

先选择比较大的孩子：如果（son<len (首先有右节点(孩子))  &&  if(A[son]<A[son+1])  (右孩子更大)）此时：son++ (选择比较大的孩子)

如果A[dad] >= A[son]  说明是大根堆，无需进行什么操作，退出循环(break)；
否则，swap( A\[dad] , A\[son]) 交换父子节点数据，dad = son ，son=2\*dad (父子节点下移)，之后继续进行大根堆判断…循环。

当满足 `son <= len` ，即子节点未超出范围时，循环执行此操作。

PS：2是因为堆存储数据性质，节点1孩子为2/3；节点3孩子为6/7……）

**2）堆排序操作 heap_sort()**

for (i = len/2;   i > 0;   i--)         // 由二叉树性质，len/2必有子节点，( 如果从0开始，此时根节点变成 **2\*len-1** )
	每个子节点执行一次，大根堆 调整HeadAdjust()     （此时形成：大根堆！）

for (i = len ;  i >1;   i--)     （执行小元素下坠操作）
	swap(arr[1], arr[i]);	// 先将第一个元素和已排好元素前一位做交换
	大根堆 调整HeadAdjust()      // 然后就是大根堆调整，因为 只有根节点，一个发生变动，所以只需调整根节点即可



#### **2.3 基数排序**

按照各个关键字位权重递增的次序（如:个、十、百)，做d趟“分配”和“收集”：

**2.3.1 手算：**
<img src=".\图片\基数排序.png" alt="基数排序" style="zoom:75%;" />

第一趟：以个位进行分配：
<img src=".\图片\基数排序1.png" alt="基数排序1" style="zoom:75%;" />

合并，得到个位递减序列
<img src=".\图片\基数排序2.png" alt="基数排序2" style="zoom:75%;" />

第二趟：以十位进行分配：
<img src=".\图片\基数排序3.png" alt="基数排序3" style="zoom:75%;" />

合并，得到十位递减序列，十位相同按个位递减
<img src=".\图片\基数排序4.png" alt="基数排序4" style="zoom:75%;" />

第三趟：以百位进行分配：
<img src=".\图片\基数排序5.png" alt="基数排序5" style="zoom:75%;" />

合并，得到百位递减序列，百位相同按十位递减，十位相同按个位递减
<img src=".\图片\基数排序6.png" alt="基数排序6" style="zoom:75%;" />

**2.3.2 编程**
基数排序得到递减序列的过程如下：
**初始化：**设置**r 个空队列**，Qr-1，Qr-2,...，Q0
按照各个 **关键字 位权重递增的次序** (个、十、百)，对 d 个关键字位分别做“分配”和“收集”
**分配：**顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入Qx队尾
**收集︰**把Qr-1,Qr-2,...,Q0各个队列中的结点依次出队并链接

时间复杂度O(d(n+r))，空间复杂度O(r)，稳定；

**2.3.3 适用范围**
基数排序擅长解决的问题:
①数据元素的关键字可以方便地拆分为d组，且d较小
②每组关键字的取值范围不大，即r较小
③数据元素个数n较大



### 3. 递归排序算法

#### 3.1 归并排序 (MergeSort)

归并∶把两个或多个已经有序的序列合并成一个

**3.1.1 手算：**

对比i、j所指元素，选择更小的一个放入k所指位置：
<img src=".\图片\归并原理讲解.png" alt="归并原理讲解" style="zoom:60%;" />

多次归并：
<img src=".\图片\归并.png" alt="归并" style="zoom:65%;" />

归并程序：
<img src=".\图片\归并程序.png" alt="归并程序" style="zoom:70%;" />

**3.1.2 程序：**

**1）归并操作 Merge()：**
归并函数输入参数：arr[] (原始待排序数组)，temp[] (临时数组，堆区分配空间，使用结束free空间)，low，(mid可省)，high位序；
定义：i / j / k （参数作用如讲解图）mid=(low+high)/2

将 arr 所有元素 拷贝至 temp中：(k=low; <=high ；k++)

归并操作：赋初始值，i或j遍历完结束循环，i=low, j=mid+1, k=i ;   (i<=mid)&&(j<=high) ;     k++
temp[i]小(<=)，arr[k]=temp[i]，i++  （反之，对j操作）

剩余数据拷贝：
i<=mid    arr[k++]=temp[i++]  （然后，对j操作）

**2）归并排序递归 MergeSort()：**
if ( low < high ) 执行下面操作，否则退出：
定义mid = (low+high)/2
MergeSort(arr,  low,  mid)
MergeSort(arr,  mid+1,  high)
merge(arr, low, high)

递归核心：限制条件，满足限制条件退出。这里限制条件为：if(low>=high)  break (return)

时间复杂度O( n\*log2(n) )，空间复杂度O(n)，稳定；



#### 3.2 快速排序 (QuickSort)

用第一个元素把待排序序列“划分”为两个部分。左边更小，右边更大。该元素的最终位置已确定。
<img src=".\图片\快速排序.png" alt="快速排序" style="zoom:30%;" />

**3.2.1 手算：**

理解原理，手算即可。

**3.2.2 程序：**

**1）划分枢轴及排序 Partition()：**

输入参数：arr[] (原始待排序数组)，low，high位序；

定义 pivot(枢轴元素) = arr[low] (定义枢轴元素为第一个元素，第一个元素low空出)

while(low<high)  (只要low<high) 就进行排序操作

只要high元素>=枢轴 且 low<high， --high，否则 空出来的low元素 = high
只要low元素<=枢轴 且 low<high， ++low，否则 空出来的high元素 = low

直到 high = low =中轴位置， 此时中轴位置 = pivot(枢轴元素)

return 中轴元素位置

**2）快速排序递归 QuickSort()：**

输入参数：arr[] (原始待排序数组)，low，high位序；

if ( low < high ) 执行下面操作，否则退出：
pivot(枢轴元素) = Partition()；
QuickSort(arr, low, pivot-1)
QuickSort(arr, pivot+1, high)

时间复杂度O( n\*log2(n) )，空间复杂度O(log2(n))，不稳定；

